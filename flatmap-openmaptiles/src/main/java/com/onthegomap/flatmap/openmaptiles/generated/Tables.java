/*
Copyright (c) 2016, KlokanTech.com & OpenMapTiles contributors.
All rights reserved.

Code license: BSD 3-Clause License

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

* Neither the name of the copyright holder nor the names of its
  contributors may be used to endorse or promote products derived from
  this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

Design license: CC-BY 4.0

See https://github.com/openmaptiles/openmaptiles/blob/master/LICENSE.md for details on usage
*/
// AUTOGENERATED BY Generate.java -- DO NOT MODIFY

package com.onthegomap.flatmap.openmaptiles.generated;

import static com.onthegomap.flatmap.openmaptiles.Expression.*;

import com.onthegomap.flatmap.FeatureCollector;
import com.onthegomap.flatmap.openmaptiles.Expression;
import com.onthegomap.flatmap.openmaptiles.MultiExpression;
import com.onthegomap.flatmap.reader.SourceFeature;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class Tables {

  public interface Row {

    SourceFeature source();
  }

  public interface Constructor {

    Row create(SourceFeature source, String mappingKey);
  }

  public interface RowHandler<T extends Row> {

    void process(T element, FeatureCollector features);
  }

  public static record OsmWaterPolygon(
    @Override String name, @Override String nameEn, @Override String nameDe, @Override String natural,
    @Override String landuse, @Override String waterway, @Override boolean isIntermittent, @Override boolean isTunnel,
    @Override boolean isBridge, @Override SourceFeature source
  ) implements Row, WithName, WithNameEn, WithNameDe, WithNatural, WithLanduse, WithWaterway, WithIsIntermittent,
    WithIsTunnel, WithIsBridge, WithSource {

    public OsmWaterPolygon(SourceFeature source, String mappingKey) {
      this(source.getString("name"), source.getString("name:en"), source.getString("name:de"),
        source.getString("natural"), source.getString("landuse"), source.getString("waterway"),
        source.getBoolean("intermittent"), source.getBoolean("tunnel"), source.getBoolean("bridge"), source);
    }

    public static final Expression MAPPING = and(
      or(matchAny("landuse", "reservoir", "basin", "salt_pond"), matchAny("leisure", "swimming_pool"),
        matchAny("natural", "water", "bay"),
        matchAny("waterway", "river", "riverbank", "stream", "canal", "drain", "ditch", "dock")),
      not(matchAny("covered", "yes")), matchType("polygon"));

    public interface Handler {

      void process(OsmWaterPolygon element, FeatureCollector features);
    }
  }

  public static record OsmWaterwayLinestring(
    @Override String waterway, @Override String name, @Override String nameEn, @Override String nameDe,
    @Override boolean isTunnel, @Override boolean isBridge, @Override boolean isIntermittent,
    @Override SourceFeature source
  ) implements Row, WithWaterway, WithName, WithNameEn, WithNameDe, WithIsTunnel, WithIsBridge, WithIsIntermittent,
    WithSource {

    public OsmWaterwayLinestring(SourceFeature source, String mappingKey) {
      this(source.getString("waterway"), source.getString("name"), source.getString("name:en"),
        source.getString("name:de"), source.getBoolean("tunnel"), source.getBoolean("bridge"),
        source.getBoolean("intermittent"), source);
    }

    public static final Expression MAPPING = and(matchAny("waterway", "stream", "river", "canal", "drain", "ditch"),
      matchType("linestring"));

    public interface Handler {

      void process(OsmWaterwayLinestring element, FeatureCollector features);
    }
  }

  public static record OsmLandcoverPolygon(
    @Override String subclass, @Override String mappingKey, @Override SourceFeature source
  ) implements Row, WithSubclass, WithMappingKey, WithSource {

    public OsmLandcoverPolygon(SourceFeature source, String mappingKey) {
      this(source.getString(mappingKey), mappingKey, source);
    }

    public static final Expression MAPPING = and(or(
      matchAny("landuse", "allotments", "farm", "farmland", "orchard", "plant_nursery", "vineyard", "grass",
        "grassland", "meadow", "forest", "village_green", "recreation_ground", "park"),
      matchAny("natural", "wood", "wetland", "fell", "grassland", "heath", "scrub", "tundra", "glacier", "bare_rock",
        "scree", "beach", "sand", "dune"), matchAny("leisure", "park", "garden", "golf_course"),
      matchAny("wetland", "bog", "swamp", "wet_meadow", "marsh", "reedbed", "saltern", "tidalflat", "saltmarsh",
        "mangrove")), matchType("polygon"));

    public interface Handler {

      void process(OsmLandcoverPolygon element, FeatureCollector features);
    }
  }

  public static record OsmLandusePolygon(
    @Override String landuse, @Override String amenity, @Override String leisure, @Override String tourism,
    @Override String place, @Override String waterway, @Override SourceFeature source
  ) implements Row, WithLanduse, WithAmenity, WithLeisure, WithTourism, WithPlace, WithWaterway, WithSource {

    public OsmLandusePolygon(SourceFeature source, String mappingKey) {
      this(source.getString("landuse"), source.getString("amenity"), source.getString("leisure"),
        source.getString("tourism"), source.getString("place"), source.getString("waterway"), source);
    }

    public static final Expression MAPPING = and(or(
      matchAny("landuse", "railway", "cemetery", "military", "residential", "commercial", "industrial", "garages",
        "retail"),
      matchAny("amenity", "bus_station", "school", "university", "kindergarten", "college", "library", "hospital"),
      matchAny("leisure", "stadium", "pitch", "playground", "track"), matchAny("tourism", "theme_park", "zoo"),
      matchAny("place", "suburb", "quarter", "neighbourhood"), matchAny("waterway", "dam")), matchType("polygon"));

    public interface Handler {

      void process(OsmLandusePolygon element, FeatureCollector features);
    }
  }

  public static record OsmPeakPoint(
    @Override String name, @Override String nameEn, @Override String nameDe, @Override String ele,
    @Override String wikipedia, @Override SourceFeature source
  ) implements Row, WithName, WithNameEn, WithNameDe, WithEle, WithWikipedia, WithSource {

    public OsmPeakPoint(SourceFeature source, String mappingKey) {
      this(source.getString("name"), source.getString("name:en"), source.getString("name:de"), source.getString("ele"),
        source.getString("wikipedia"), source);
    }

    public static final Expression MAPPING = and(matchAny("natural", "peak", "volcano"), matchType("point"));

    public interface Handler {

      void process(OsmPeakPoint element, FeatureCollector features);
    }
  }

  public static record OsmParkPolygon(
    @Override String name, @Override String nameEn, @Override String nameDe, @Override String landuse,
    @Override String leisure, @Override String boundary, @Override String protectionTitle,
    @Override SourceFeature source
  ) implements Row, WithName, WithNameEn, WithNameDe, WithLanduse, WithLeisure, WithBoundary, WithProtectionTitle,
    WithSource {

    public OsmParkPolygon(SourceFeature source, String mappingKey) {
      this(source.getString("name"), source.getString("name:en"), source.getString("name:de"),
        source.getString("landuse"), source.getString("leisure"), source.getString("boundary"),
        source.getString("protection_title"), source);
    }

    public static final Expression MAPPING = and(
      or(matchAny("leisure", "nature_reserve"), matchAny("boundary", "national_park", "protected_area")),
      matchType("polygon"));

    public interface Handler {

      void process(OsmParkPolygon element, FeatureCollector features);
    }
  }

  public static record OsmAerowayPolygon(
    @Override String ref, @Override String aeroway, @Override SourceFeature source
  ) implements Row, WithRef, WithAeroway, WithSource {

    public OsmAerowayPolygon(SourceFeature source, String mappingKey) {
      this(source.getString("ref"), source.getString(mappingKey), source);
    }

    public static final Expression MAPPING = and(
      or(matchAny("aeroway", "aerodrome", "heliport", "runway", "helipad", "taxiway", "apron"),
        matchAny("area:aeroway", "aerodrome", "heliport", "runway", "helipad", "taxiway", "apron")),
      matchType("polygon"));

    public interface Handler {

      void process(OsmAerowayPolygon element, FeatureCollector features);
    }
  }

  public static record OsmAerowayLinestring(
    @Override String ref, @Override String aeroway, @Override SourceFeature source
  ) implements Row, WithRef, WithAeroway, WithSource {

    public OsmAerowayLinestring(SourceFeature source, String mappingKey) {
      this(source.getString("ref"), source.getString("aeroway"), source);
    }

    public static final Expression MAPPING = and(matchAny("aeroway", "runway", "taxiway"), matchType("linestring"));

    public interface Handler {

      void process(OsmAerowayLinestring element, FeatureCollector features);
    }
  }

  public static record OsmAerowayPoint(
    @Override String ref, @Override String aeroway, @Override SourceFeature source
  ) implements Row, WithRef, WithAeroway, WithSource {

    public OsmAerowayPoint(SourceFeature source, String mappingKey) {
      this(source.getString("ref"), source.getString("aeroway"), source);
    }

    public static final Expression MAPPING = and(matchAny("aeroway", "gate"), matchType("point"));

    public interface Handler {

      void process(OsmAerowayPoint element, FeatureCollector features);
    }
  }

  public static record OsmHighwayLinestring(
    @Override String highway, @Override String construction, @Override String ref, @Override String network,
    @Override int zOrder, @Override long layer, @Override long level, @Override boolean indoor, @Override String name,
    @Override String nameEn, @Override String nameDe, @Override String shortName, @Override boolean isTunnel,
    @Override boolean isBridge, @Override boolean isRamp, @Override boolean isFord, @Override int isOneway,
    @Override boolean isArea, @Override String service, @Override String usage, @Override String publicTransport,
    @Override String manMade, @Override String bicycle, @Override String foot, @Override String horse,
    @Override String mtbScale, @Override String surface, @Override SourceFeature source
  ) implements Row, WithHighway, WithConstruction, WithRef, WithNetwork, WithZOrder, WithLayer, WithLevel, WithIndoor,
    WithName, WithNameEn, WithNameDe, WithShortName, WithIsTunnel, WithIsBridge, WithIsRamp, WithIsFord, WithIsOneway,
    WithIsArea, WithService, WithUsage, WithPublicTransport, WithManMade, WithBicycle, WithFoot, WithHorse,
    WithMtbScale, WithSurface, WithSource {

    public OsmHighwayLinestring(SourceFeature source, String mappingKey) {
      this(source.getString("highway"), source.getString("construction"), source.getString("ref"),
        source.getString("network"), source.getWayZorder(), source.getLong("layer"), source.getLong("level"),
        source.getBoolean("indoor"), source.getString("name"), source.getString("name:en"), source.getString("name:de"),
        source.getString("short_name"), source.getBoolean("tunnel"), source.getBoolean("bridge"),
        source.getBoolean("ramp"), source.getBoolean("ford"), source.getDirection("oneway"), source.getBoolean("area"),
        source.getString("service"), source.getString("usage"), source.getString("public_transport"),
        source.getString("man_made"), source.getString("bicycle"), source.getString("foot"), source.getString("horse"),
        source.getString("mtb:scale"), source.getString("surface"), source);
    }

    public static final Expression MAPPING = and(or(
      matchAny("highway", "motorway", "motorway_link", "trunk", "trunk_link", "primary", "primary_link", "secondary",
        "secondary_link", "tertiary", "tertiary_link", "unclassified", "residential", "living_street", "road",
        "pedestrian", "path", "footway", "cycleway", "steps", "bridleway", "corridor", "service", "track", "raceway",
        "construction"), matchAny("public_transport", "platform"), matchAny("man_made", "pier")),
      matchType("linestring"));

    public interface Handler {

      void process(OsmHighwayLinestring element, FeatureCollector features);
    }
  }

  public static record OsmRailwayLinestring(
    @Override String railway, @Override String ref, @Override String network, @Override int zOrder,
    @Override long layer, @Override long level, @Override boolean indoor, @Override String name,
    @Override String nameEn, @Override String nameDe, @Override String shortName, @Override boolean isTunnel,
    @Override boolean isBridge, @Override boolean isRamp, @Override boolean isFord, @Override int isOneway,
    @Override boolean isArea, @Override String service, @Override String usage, @Override SourceFeature source
  ) implements Row, WithRailway, WithRef, WithNetwork, WithZOrder, WithLayer, WithLevel, WithIndoor, WithName,
    WithNameEn, WithNameDe, WithShortName, WithIsTunnel, WithIsBridge, WithIsRamp, WithIsFord, WithIsOneway, WithIsArea,
    WithService, WithUsage, WithSource {

    public OsmRailwayLinestring(SourceFeature source, String mappingKey) {
      this(source.getString("railway"), source.getString("ref"), source.getString("network"), source.getWayZorder(),
        source.getLong("layer"), source.getLong("level"), source.getBoolean("indoor"), source.getString("name"),
        source.getString("name:en"), source.getString("name:de"), source.getString("short_name"),
        source.getBoolean("tunnel"), source.getBoolean("bridge"), source.getBoolean("ramp"), source.getBoolean("ford"),
        source.getDirection("oneway"), source.getBoolean("area"), source.getString("service"),
        source.getString("usage"), source);
    }

    public static final Expression MAPPING = and(
      matchAny("railway", "rail", "narrow_gauge", "preserved", "funicular", "subway", "light_rail", "monorail", "tram"),
      matchType("linestring"));

    public interface Handler {

      void process(OsmRailwayLinestring element, FeatureCollector features);
    }
  }

  public static record OsmAerialwayLinestring(
    @Override String aerialway, @Override int zOrder, @Override long layer, @Override String name,
    @Override String nameEn, @Override String nameDe, @Override String shortName, @Override boolean isTunnel,
    @Override boolean isBridge, @Override boolean isRamp, @Override boolean isFord, @Override int isOneway,
    @Override boolean isArea, @Override String service, @Override String usage, @Override SourceFeature source
  ) implements Row, WithAerialway, WithZOrder, WithLayer, WithName, WithNameEn, WithNameDe, WithShortName, WithIsTunnel,
    WithIsBridge, WithIsRamp, WithIsFord, WithIsOneway, WithIsArea, WithService, WithUsage, WithSource {

    public OsmAerialwayLinestring(SourceFeature source, String mappingKey) {
      this(source.getString("aerialway"), source.getWayZorder(), source.getLong("layer"), source.getString("name"),
        source.getString("name:en"), source.getString("name:de"), source.getString("short_name"),
        source.getBoolean("tunnel"), source.getBoolean("bridge"), source.getBoolean("ramp"), source.getBoolean("ford"),
        source.getDirection("oneway"), source.getBoolean("area"), source.getString("service"),
        source.getString("usage"), source);
    }

    public static final Expression MAPPING = and(matchAny("aerialway", "cable_car", "gondola"),
      matchType("linestring"));

    public interface Handler {

      void process(OsmAerialwayLinestring element, FeatureCollector features);
    }
  }

  public static record OsmShipwayLinestring(
    @Override String shipway, @Override int zOrder, @Override long layer, @Override String name,
    @Override String nameEn, @Override String nameDe, @Override String shortName, @Override boolean isTunnel,
    @Override boolean isBridge, @Override boolean isRamp, @Override boolean isFord, @Override int isOneway,
    @Override boolean isArea, @Override String service, @Override String usage, @Override SourceFeature source
  ) implements Row, WithShipway, WithZOrder, WithLayer, WithName, WithNameEn, WithNameDe, WithShortName, WithIsTunnel,
    WithIsBridge, WithIsRamp, WithIsFord, WithIsOneway, WithIsArea, WithService, WithUsage, WithSource {

    public OsmShipwayLinestring(SourceFeature source, String mappingKey) {
      this(source.getString("route"), source.getWayZorder(), source.getLong("layer"), source.getString("name"),
        source.getString("name:en"), source.getString("name:de"), source.getString("short_name"),
        source.getBoolean("tunnel"), source.getBoolean("bridge"), source.getBoolean("ramp"), source.getBoolean("ford"),
        source.getDirection("oneway"), source.getBoolean("area"), source.getString("service"),
        source.getString("usage"), source);
    }

    public static final Expression MAPPING = and(matchAny("route", "ferry"), matchType("linestring"));

    public interface Handler {

      void process(OsmShipwayLinestring element, FeatureCollector features);
    }
  }

  public static record OsmHighwayPolygon(
    @Override String highway, @Override int zOrder, @Override long layer, @Override long level,
    @Override boolean indoor, @Override boolean isArea, @Override String publicTransport, @Override String manMade,
    @Override SourceFeature source
  ) implements Row, WithHighway, WithZOrder, WithLayer, WithLevel, WithIndoor, WithIsArea, WithPublicTransport,
    WithManMade, WithSource {

    public OsmHighwayPolygon(SourceFeature source, String mappingKey) {
      this(source.getString("highway"), source.getWayZorder(), source.getLong("layer"), source.getLong("level"),
        source.getBoolean("indoor"), source.getBoolean("area"), source.getString("public_transport"),
        source.getString("man_made"), source);
    }

    public static final Expression MAPPING = and(
      or(matchAny("highway", "path", "cycleway", "bridleway", "footway", "corridor", "pedestrian", "steps"),
        matchAny("public_transport", "platform"), matchAny("man_made", "bridge", "pier")), matchType("polygon"));

    public interface Handler {

      void process(OsmHighwayPolygon element, FeatureCollector features);
    }
  }

  public static record OsmBuildingPolygon(
    @Override String material, @Override String colour, @Override String building, @Override String buildingpart,
    @Override String buildingheight, @Override String buildingminHeight, @Override String buildinglevels,
    @Override String buildingminLevel, @Override String height, @Override String minHeight, @Override String levels,
    @Override String minLevel, @Override SourceFeature source
  ) implements Row, WithMaterial, WithColour, WithBuilding, WithBuildingpart, WithBuildingheight, WithBuildingminHeight,
    WithBuildinglevels, WithBuildingminLevel, WithHeight, WithMinHeight, WithLevels, WithMinLevel, WithSource {

    public OsmBuildingPolygon(SourceFeature source, String mappingKey) {
      this(source.getString("building:material"), source.getString("building:colour"), source.getString("building"),
        source.getString("building:part"), source.getString("building:height"), source.getString("building:min_height"),
        source.getString("building:levels"), source.getString("building:min_level"), source.getString("height"),
        source.getString("min_height"), source.getString("levels"), source.getString("min_level"), source);
    }

    public static final Expression MAPPING = and(
      or(matchField("building:part"), matchField("building"), matchAny("aeroway", "terminal", "hangar")),
      not(matchAny("building", "no", "none", "No")), not(matchAny("building:part", "no", "none", "No")),
      not(matchAny("man_made", "bridge")), matchType("polygon"));

    public interface Handler {

      void process(OsmBuildingPolygon element, FeatureCollector features);
    }
  }

  public static record OsmMarinePoint(
    @Override String name, @Override String nameEn, @Override String nameDe, @Override String place,
    @Override long rank, @Override boolean isIntermittent, @Override SourceFeature source
  ) implements Row, WithName, WithNameEn, WithNameDe, WithPlace, WithRank, WithIsIntermittent, WithSource {

    public OsmMarinePoint(SourceFeature source, String mappingKey) {
      this(source.getString("name"), source.getString("name:en"), source.getString("name:de"),
        source.getString("place"), source.getLong("rank"), source.getBoolean("intermittent"), source);
    }

    public static final Expression MAPPING = and(matchAny("place", "ocean", "sea"), matchField("name"),
      matchType("point"));

    public interface Handler {

      void process(OsmMarinePoint element, FeatureCollector features);
    }
  }

  public static record OsmContinentPoint(
    @Override String name, @Override String nameEn, @Override String nameDe, @Override SourceFeature source
  ) implements Row, WithName, WithNameEn, WithNameDe, WithSource {

    public OsmContinentPoint(SourceFeature source, String mappingKey) {
      this(source.getString("name"), source.getString("name:en"), source.getString("name:de"), source);
    }

    public static final Expression MAPPING = and(matchAny("place", "continent"), matchField("name"),
      matchType("point"));

    public interface Handler {

      void process(OsmContinentPoint element, FeatureCollector features);
    }
  }

  public static record OsmCountryPoint(
    @Override String name, @Override String nameEn, @Override String nameDe, @Override long rank,
    @Override String countryCodeIso31661Alpha2, @Override String iso31661Alpha2, @Override String iso31661,
    @Override SourceFeature source
  ) implements Row, WithName, WithNameEn, WithNameDe, WithRank, WithCountryCodeIso31661Alpha2, WithIso31661Alpha2,
    WithIso31661, WithSource {

    public OsmCountryPoint(SourceFeature source, String mappingKey) {
      this(source.getString("name"), source.getString("name:en"), source.getString("name:de"), source.getLong("rank"),
        source.getString("country_code_iso3166_1_alpha_2"), source.getString("ISO3166-1:alpha2"),
        source.getString("ISO3166-1"), source);
    }

    public static final Expression MAPPING = and(matchAny("place", "country"), matchField("name"), matchType("point"));

    public interface Handler {

      void process(OsmCountryPoint element, FeatureCollector features);
    }
  }

  public static record OsmIslandPolygon(
    @Override String name, @Override String nameEn, @Override String nameDe, @Override long rank,
    @Override SourceFeature source
  ) implements Row, WithName, WithNameEn, WithNameDe, WithRank, WithSource {

    public OsmIslandPolygon(SourceFeature source, String mappingKey) {
      this(source.getString("name"), source.getString("name:en"), source.getString("name:de"), source.getLong("rank"),
        source);
    }

    public static final Expression MAPPING = and(matchAny("place", "island"), matchField("name"), matchType("polygon"));

    public interface Handler {

      void process(OsmIslandPolygon element, FeatureCollector features);
    }
  }

  public static record OsmIslandPoint(
    @Override String name, @Override String nameEn, @Override String nameDe, @Override long rank,
    @Override SourceFeature source
  ) implements Row, WithName, WithNameEn, WithNameDe, WithRank, WithSource {

    public OsmIslandPoint(SourceFeature source, String mappingKey) {
      this(source.getString("name"), source.getString("name:en"), source.getString("name:de"), source.getLong("rank"),
        source);
    }

    public static final Expression MAPPING = and(matchAny("place", "island"), matchField("name"), matchType("point"));

    public interface Handler {

      void process(OsmIslandPoint element, FeatureCollector features);
    }
  }

  public static record OsmStatePoint(
    @Override String name, @Override String nameEn, @Override String nameDe, @Override String isInCountry,
    @Override String isInCountryCode, @Override String ref, @Override long rank, @Override SourceFeature source
  ) implements Row, WithName, WithNameEn, WithNameDe, WithIsInCountry, WithIsInCountryCode, WithRef, WithRank,
    WithSource {

    public OsmStatePoint(SourceFeature source, String mappingKey) {
      this(source.getString("name"), source.getString("name:en"), source.getString("name:de"),
        source.getString("is_in:country"), source.getString("is_in:country_code"), source.getString("ref"),
        source.getLong("rank"), source);
    }

    public static final Expression MAPPING = and(matchAny("place", "state"), matchField("name"), matchType("point"));

    public interface Handler {

      void process(OsmStatePoint element, FeatureCollector features);
    }
  }

  public static record OsmCityPoint(
    @Override String name, @Override String nameEn, @Override String nameDe, @Override String place,
    @Override long population, @Override String capital, @Override long rank, @Override SourceFeature source
  ) implements Row, WithName, WithNameEn, WithNameDe, WithPlace, WithPopulation, WithCapital, WithRank, WithSource {

    public OsmCityPoint(SourceFeature source, String mappingKey) {
      this(source.getString("name"), source.getString("name:en"), source.getString("name:de"),
        source.getString("place"), source.getLong("population"), source.getString("capital"), source.getLong("rank"),
        source);
    }

    public static final Expression MAPPING = and(
      matchAny("place", "city", "town", "village", "hamlet", "suburb", "quarter", "neighbourhood", "isolated_dwelling"),
      matchField("name"), matchType("point"));

    public interface Handler {

      void process(OsmCityPoint element, FeatureCollector features);
    }
  }

  public static record OsmHousenumberPoint(@Override String housenumber, @Override SourceFeature source) implements Row,
    WithHousenumber, WithSource {

    public OsmHousenumberPoint(SourceFeature source, String mappingKey) {
      this(source.getString("addr:housenumber"), source);
    }

    public static final Expression MAPPING = or(and(matchField("addr:housenumber"), matchType("point")),
      and(matchField("addr:housenumber"), matchType("polygon")));

    public interface Handler {

      void process(OsmHousenumberPoint element, FeatureCollector features);
    }
  }

  public static record OsmPoiPoint(
    @Override String name, @Override String nameEn, @Override String nameDe, @Override String subclass,
    @Override String mappingKey, @Override String station, @Override String funicular, @Override String information,
    @Override String uicRef, @Override String religion, @Override long level, @Override boolean indoor,
    @Override long layer, @Override String sport, @Override SourceFeature source
  ) implements Row, WithName, WithNameEn, WithNameDe, WithSubclass, WithMappingKey, WithStation, WithFunicular,
    WithInformation, WithUicRef, WithReligion, WithLevel, WithIndoor, WithLayer, WithSport, WithSource {

    public OsmPoiPoint(SourceFeature source, String mappingKey) {
      this(source.getString("name"), source.getString("name:en"), source.getString("name:de"),
        source.getString(mappingKey), mappingKey, source.getString("station"), source.getString("funicular"),
        source.getString("information"), source.getString("uic_ref"), source.getString("religion"),
        source.getLong("level"), source.getBoolean("indoor"), source.getLong("layer"), source.getString("sport"),
        source);
    }

    public static final Expression MAPPING = and(or(matchAny("aerialway", "station"),
      matchAny("amenity", "arts_centre", "bank", "bar", "bbq", "bicycle_parking", "bicycle_rental", "biergarten",
        "bus_station", "cafe", "cinema", "clinic", "college", "community_centre", "courthouse", "dentist", "doctors",
        "drinking_water", "embassy", "fast_food", "ferry_terminal", "fire_station", "food_court", "fuel", "grave_yard",
        "hospital", "ice_cream", "kindergarten", "library", "marketplace", "motorcycle_parking", "nightclub",
        "nursing_home", "parking", "pharmacy", "place_of_worship", "police", "post_box", "post_office", "prison", "pub",
        "public_building", "recycling", "restaurant", "school", "shelter", "swimming_pool", "taxi", "telephone",
        "theatre", "toilets", "townhall", "university", "veterinary", "waste_basket"),
      matchAny("barrier", "bollard", "border_control", "cycle_barrier", "gate", "lift_gate", "sally_port", "stile",
        "toll_booth"), matchAny("building", "dormitory"), matchAny("highway", "bus_stop"),
      matchAny("historic", "monument", "castle", "ruins"),
      matchAny("landuse", "basin", "brownfield", "cemetery", "reservoir", "winter_sports"),
      matchAny("leisure", "dog_park", "escape_game", "garden", "golf_course", "ice_rink", "hackerspace", "marina",
        "miniature_golf", "park", "pitch", "playground", "sports_centre", "stadium", "swimming_area", "swimming_pool",
        "water_park"), matchAny("railway", "halt", "station", "subway_entrance", "train_station_entrance", "tram_stop"),
      matchAny("shop", "accessories", "alcohol", "antiques", "art", "bag", "bakery", "beauty", "bed", "beverages",
        "bicycle", "books", "boutique", "butcher", "camera", "car", "car_repair", "car_parts", "carpet", "charity",
        "chemist", "chocolate", "clothes", "coffee", "computer", "confectionery", "convenience", "copyshop",
        "cosmetics", "deli", "delicatessen", "department_store", "doityourself", "dry_cleaning", "electronics",
        "erotic", "fabric", "florist", "frozen_food", "furniture", "garden_centre", "general", "gift", "greengrocer",
        "hairdresser", "hardware", "hearing_aids", "hifi", "ice_cream", "interior_decoration", "jewelry", "kiosk",
        "lamps", "laundry", "mall", "massage", "mobile_phone", "motorcycle", "music", "musical_instrument", "newsagent",
        "optician", "outdoor", "perfume", "perfumery", "pet", "photo", "second_hand", "shoes", "sports", "stationery",
        "supermarket", "tailor", "tattoo", "ticket", "tobacco", "toys", "travel_agency", "video", "video_games",
        "watches", "weapons", "wholesale", "wine"),
      matchAny("sport", "american_football", "archery", "athletics", "australian_football", "badminton", "baseball",
        "basketball", "beachvolleyball", "billiards", "bmx", "boules", "bowls", "boxing", "canadian_football", "canoe",
        "chess", "climbing", "climbing_adventure", "cricket", "cricket_nets", "croquet", "curling", "cycling",
        "disc_golf", "diving", "dog_racing", "equestrian", "fatsal", "field_hockey", "free_flying", "gaelic_games",
        "golf", "gymnastics", "handball", "hockey", "horse_racing", "horseshoes", "ice_hockey", "ice_stock", "judo",
        "karting", "korfball", "long_jump", "model_aerodrome", "motocross", "motor", "multi", "netball", "orienteering",
        "paddle_tennis", "paintball", "paragliding", "pelota", "racquet", "rc_car", "rowing", "rugby", "rugby_league",
        "rugby_union", "running", "sailing", "scuba_diving", "shooting", "shooting_range", "skateboard", "skating",
        "skiing", "soccer", "surfing", "swimming", "table_soccer", "table_tennis", "team_handball", "tennis",
        "toboggan", "volleyball", "water_ski", "yoga"),
      matchAny("tourism", "alpine_hut", "aquarium", "artwork", "attraction", "bed_and_breakfast", "camp_site",
        "caravan_site", "chalet", "gallery", "guest_house", "hostel", "hotel", "information", "motel", "museum",
        "picnic_site", "theme_park", "viewpoint", "zoo"), matchAny("waterway", "dock")), matchType("point"));

    public interface Handler {

      void process(OsmPoiPoint element, FeatureCollector features);
    }
  }

  public static record OsmPoiPolygon(
    @Override String name, @Override String nameEn, @Override String nameDe, @Override String subclass,
    @Override String mappingKey, @Override String station, @Override String funicular, @Override String information,
    @Override String uicRef, @Override String religion, @Override long level, @Override boolean indoor,
    @Override long layer, @Override String sport, @Override SourceFeature source
  ) implements Row, WithName, WithNameEn, WithNameDe, WithSubclass, WithMappingKey, WithStation, WithFunicular,
    WithInformation, WithUicRef, WithReligion, WithLevel, WithIndoor, WithLayer, WithSport, WithSource {

    public OsmPoiPolygon(SourceFeature source, String mappingKey) {
      this(source.getString("name"), source.getString("name:en"), source.getString("name:de"),
        source.getString(mappingKey), mappingKey, source.getString("station"), source.getString("funicular"),
        source.getString("information"), source.getString("uic_ref"), source.getString("religion"),
        source.getLong("level"), source.getBoolean("indoor"), source.getLong("layer"), source.getString("sport"),
        source);
    }

    public static final Expression MAPPING = and(or(matchAny("aerialway", "station"),
      matchAny("amenity", "arts_centre", "bank", "bar", "bbq", "bicycle_parking", "bicycle_rental", "biergarten",
        "bus_station", "cafe", "cinema", "clinic", "college", "community_centre", "courthouse", "dentist", "doctors",
        "drinking_water", "embassy", "fast_food", "ferry_terminal", "fire_station", "food_court", "fuel", "grave_yard",
        "hospital", "ice_cream", "kindergarten", "library", "marketplace", "motorcycle_parking", "nightclub",
        "nursing_home", "parking", "pharmacy", "place_of_worship", "police", "post_box", "post_office", "prison", "pub",
        "public_building", "recycling", "restaurant", "school", "shelter", "swimming_pool", "taxi", "telephone",
        "theatre", "toilets", "townhall", "university", "veterinary", "waste_basket"),
      matchAny("barrier", "bollard", "border_control", "cycle_barrier", "gate", "lift_gate", "sally_port", "stile",
        "toll_booth"), matchAny("building", "dormitory"), matchAny("highway", "bus_stop"),
      matchAny("historic", "monument", "castle", "ruins"),
      matchAny("landuse", "basin", "brownfield", "cemetery", "reservoir", "winter_sports"),
      matchAny("leisure", "dog_park", "escape_game", "garden", "golf_course", "ice_rink", "hackerspace", "marina",
        "miniature_golf", "park", "pitch", "playground", "sports_centre", "stadium", "swimming_area", "swimming_pool",
        "water_park"), matchAny("railway", "halt", "station", "subway_entrance", "train_station_entrance", "tram_stop"),
      matchAny("shop", "accessories", "alcohol", "antiques", "art", "bag", "bakery", "beauty", "bed", "beverages",
        "bicycle", "books", "boutique", "butcher", "camera", "car", "car_repair", "car_parts", "carpet", "charity",
        "chemist", "chocolate", "clothes", "coffee", "computer", "confectionery", "convenience", "copyshop",
        "cosmetics", "deli", "delicatessen", "department_store", "doityourself", "dry_cleaning", "electronics",
        "erotic", "fabric", "florist", "frozen_food", "furniture", "garden_centre", "general", "gift", "greengrocer",
        "hairdresser", "hardware", "hearing_aids", "hifi", "ice_cream", "interior_decoration", "jewelry", "kiosk",
        "lamps", "laundry", "mall", "massage", "mobile_phone", "motorcycle", "music", "musical_instrument", "newsagent",
        "optician", "outdoor", "perfume", "perfumery", "pet", "photo", "second_hand", "shoes", "sports", "stationery",
        "supermarket", "tailor", "tattoo", "ticket", "tobacco", "toys", "travel_agency", "video", "video_games",
        "watches", "weapons", "wholesale", "wine"),
      matchAny("sport", "american_football", "archery", "athletics", "australian_football", "badminton", "baseball",
        "basketball", "beachvolleyball", "billiards", "bmx", "boules", "bowls", "boxing", "canadian_football", "canoe",
        "chess", "climbing", "climbing_adventure", "cricket", "cricket_nets", "croquet", "curling", "cycling",
        "disc_golf", "diving", "dog_racing", "equestrian", "fatsal", "field_hockey", "free_flying", "gaelic_games",
        "golf", "gymnastics", "handball", "hockey", "horse_racing", "horseshoes", "ice_hockey", "ice_stock", "judo",
        "karting", "korfball", "long_jump", "model_aerodrome", "motocross", "motor", "multi", "netball", "orienteering",
        "paddle_tennis", "paintball", "paragliding", "pelota", "racquet", "rc_car", "rowing", "rugby", "rugby_league",
        "rugby_union", "running", "sailing", "scuba_diving", "shooting", "shooting_range", "skateboard", "skating",
        "skiing", "soccer", "surfing", "swimming", "table_soccer", "table_tennis", "team_handball", "tennis",
        "toboggan", "volleyball", "water_ski", "yoga"),
      matchAny("tourism", "alpine_hut", "aquarium", "artwork", "attraction", "bed_and_breakfast", "camp_site",
        "caravan_site", "chalet", "gallery", "guest_house", "hostel", "hotel", "information", "motel", "museum",
        "picnic_site", "theme_park", "viewpoint", "zoo"), matchAny("waterway", "dock")), matchType("polygon"));

    public interface Handler {

      void process(OsmPoiPolygon element, FeatureCollector features);
    }
  }

  public static record OsmAerodromeLabelPoint(
    @Override String name, @Override String nameEn, @Override String nameDe, @Override String aerodromeType,
    @Override String aerodrome, @Override String military, @Override String iata, @Override String icao,
    @Override String ele, @Override SourceFeature source
  ) implements Row, WithName, WithNameEn, WithNameDe, WithAerodromeType, WithAerodrome, WithMilitary, WithIata,
    WithIcao, WithEle, WithSource {

    public OsmAerodromeLabelPoint(SourceFeature source, String mappingKey) {
      this(source.getString("name"), source.getString("name:en"), source.getString("name:de"),
        source.getString("aerodrome:type"), source.getString("aerodrome"), source.getString("military"),
        source.getString("iata"), source.getString("icao"), source.getString("ele"), source);
    }

    public static final Expression MAPPING = or(and(matchAny("aeroway", "aerodrome"), matchType("point")),
      and(matchAny("aeroway", "aerodrome"), matchType("polygon")));

    public interface Handler {

      void process(OsmAerodromeLabelPoint element, FeatureCollector features);
    }
  }

  public interface WithAdminLevel {

    long adminLevel();
  }

  public interface WithAerialway {

    String aerialway();
  }

  public interface WithAerodrome {

    String aerodrome();
  }

  public interface WithAerodromeType {

    String aerodromeType();
  }

  public interface WithAeroway {

    String aeroway();
  }

  public interface WithAmenity {

    String amenity();
  }

  public interface WithBicycle {

    String bicycle();
  }

  public interface WithBoundary {

    String boundary();
  }

  public interface WithBuilding {

    String building();
  }

  public interface WithBuildingheight {

    String buildingheight();
  }

  public interface WithBuildinglevels {

    String buildinglevels();
  }

  public interface WithBuildingminHeight {

    String buildingminHeight();
  }

  public interface WithBuildingminLevel {

    String buildingminLevel();
  }

  public interface WithBuildingpart {

    String buildingpart();
  }

  public interface WithCapital {

    String capital();
  }

  public interface WithClaimedBy {

    String claimedBy();
  }

  public interface WithColour {

    String colour();
  }

  public interface WithConstruction {

    String construction();
  }

  public interface WithCountryCodeIso31661Alpha2 {

    String countryCodeIso31661Alpha2();
  }

  public interface WithDisputedBy {

    String disputedBy();
  }

  public interface WithEle {

    String ele();
  }

  public interface WithFoot {

    String foot();
  }

  public interface WithFunicular {

    String funicular();
  }

  public interface WithHeight {

    String height();
  }

  public interface WithHighway {

    String highway();
  }

  public interface WithHorse {

    String horse();
  }

  public interface WithHousenumber {

    String housenumber();
  }

  public interface WithIata {

    String iata();
  }

  public interface WithIcao {

    String icao();
  }

  public interface WithIndoor {

    boolean indoor();
  }

  public interface WithInformation {

    String information();
  }

  public interface WithIsArea {

    boolean isArea();
  }

  public interface WithIsBridge {

    boolean isBridge();
  }

  public interface WithIsFord {

    boolean isFord();
  }

  public interface WithIsInCountry {

    String isInCountry();
  }

  public interface WithIsInCountryCode {

    String isInCountryCode();
  }

  public interface WithIsIntermittent {

    boolean isIntermittent();
  }

  public interface WithIsOneway {

    int isOneway();
  }

  public interface WithIsRamp {

    boolean isRamp();
  }

  public interface WithIsTunnel {

    boolean isTunnel();
  }

  public interface WithIso31661 {

    String iso31661();
  }

  public interface WithIso31661Alpha2 {

    String iso31661Alpha2();
  }

  public interface WithLanduse {

    String landuse();
  }

  public interface WithLayer {

    long layer();
  }

  public interface WithLeisure {

    String leisure();
  }

  public interface WithLevel {

    long level();
  }

  public interface WithLevels {

    String levels();
  }

  public interface WithManMade {

    String manMade();
  }

  public interface WithMappingKey {

    String mappingKey();
  }

  public interface WithMaterial {

    String material();
  }

  public interface WithMilitary {

    String military();
  }

  public interface WithMinHeight {

    String minHeight();
  }

  public interface WithMinLevel {

    String minLevel();
  }

  public interface WithMtbScale {

    String mtbScale();
  }

  public interface WithName {

    String name();
  }

  public interface WithNameDe {

    String nameDe();
  }

  public interface WithNameEn {

    String nameEn();
  }

  public interface WithNatural {

    String natural();
  }

  public interface WithNetwork {

    String network();
  }

  public interface WithPlace {

    String place();
  }

  public interface WithPopulation {

    long population();
  }

  public interface WithProtectionTitle {

    String protectionTitle();
  }

  public interface WithPublicTransport {

    String publicTransport();
  }

  public interface WithRailway {

    String railway();
  }

  public interface WithRank {

    long rank();
  }

  public interface WithRef {

    String ref();
  }

  public interface WithRelbuildingheight {

    String relbuildingheight();
  }

  public interface WithRelbuildinglevels {

    String relbuildinglevels();
  }

  public interface WithRelbuildingminHeight {

    String relbuildingminHeight();
  }

  public interface WithRelbuildingminLevel {

    String relbuildingminLevel();
  }

  public interface WithRelheight {

    String relheight();
  }

  public interface WithReligion {

    String religion();
  }

  public interface WithRellevels {

    String rellevels();
  }

  public interface WithRelminHeight {

    String relminHeight();
  }

  public interface WithRelminLevel {

    String relminLevel();
  }

  public interface WithService {

    String service();
  }

  public interface WithShipway {

    String shipway();
  }

  public interface WithShortName {

    String shortName();
  }

  public interface WithSource {

    SourceFeature source();
  }

  public interface WithSport {

    String sport();
  }

  public interface WithStation {

    String station();
  }

  public interface WithSubclass {

    String subclass();
  }

  public interface WithSurface {

    String surface();
  }

  public interface WithTourism {

    String tourism();
  }

  public interface WithUicRef {

    String uicRef();
  }

  public interface WithUsage {

    String usage();
  }

  public interface WithWaterway {

    String waterway();
  }

  public interface WithWikipedia {

    String wikipedia();
  }

  public interface WithZOrder {

    int zOrder();
  }

  public static final MultiExpression<Constructor> MAPPINGS = MultiExpression.of(Map.ofEntries(
    Map.entry(OsmWaterPolygon::new, OsmWaterPolygon.MAPPING),
    Map.entry(OsmWaterwayLinestring::new, OsmWaterwayLinestring.MAPPING),
    Map.entry(OsmLandcoverPolygon::new, OsmLandcoverPolygon.MAPPING),
    Map.entry(OsmLandusePolygon::new, OsmLandusePolygon.MAPPING),
    Map.entry(OsmPeakPoint::new, OsmPeakPoint.MAPPING),
    Map.entry(OsmParkPolygon::new, OsmParkPolygon.MAPPING),
    Map.entry(OsmAerowayPolygon::new, OsmAerowayPolygon.MAPPING),
    Map.entry(OsmAerowayLinestring::new, OsmAerowayLinestring.MAPPING),
    Map.entry(OsmAerowayPoint::new, OsmAerowayPoint.MAPPING),
    Map.entry(OsmHighwayLinestring::new, OsmHighwayLinestring.MAPPING),
    Map.entry(OsmRailwayLinestring::new, OsmRailwayLinestring.MAPPING),
    Map.entry(OsmAerialwayLinestring::new, OsmAerialwayLinestring.MAPPING),
    Map.entry(OsmShipwayLinestring::new, OsmShipwayLinestring.MAPPING),
    Map.entry(OsmHighwayPolygon::new, OsmHighwayPolygon.MAPPING),
    Map.entry(OsmBuildingPolygon::new, OsmBuildingPolygon.MAPPING),
    Map.entry(OsmMarinePoint::new, OsmMarinePoint.MAPPING),
    Map.entry(OsmContinentPoint::new, OsmContinentPoint.MAPPING),
    Map.entry(OsmCountryPoint::new, OsmCountryPoint.MAPPING),
    Map.entry(OsmIslandPolygon::new, OsmIslandPolygon.MAPPING),
    Map.entry(OsmIslandPoint::new, OsmIslandPoint.MAPPING),
    Map.entry(OsmStatePoint::new, OsmStatePoint.MAPPING),
    Map.entry(OsmCityPoint::new, OsmCityPoint.MAPPING),
    Map.entry(OsmHousenumberPoint::new, OsmHousenumberPoint.MAPPING),
    Map.entry(OsmPoiPoint::new, OsmPoiPoint.MAPPING),
    Map.entry(OsmPoiPolygon::new, OsmPoiPolygon.MAPPING),
    Map.entry(OsmAerodromeLabelPoint::new, OsmAerodromeLabelPoint.MAPPING)
  ));

  public static Map<Class<? extends Row>, Set<Class<?>>> generateHandlerClassMap(List<?> handlers) {
    Map<Class<? extends Row>, Set<Class<?>>> result = new HashMap<>();
    for (var handler : handlers) {
      if (handler instanceof OsmWaterPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmWaterPolygon.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmWaterwayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmWaterwayLinestring.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmLandcoverPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmLandcoverPolygon.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmLandusePolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmLandusePolygon.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmPeakPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmPeakPoint.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmParkPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmParkPolygon.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmAerowayPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmAerowayPolygon.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmAerowayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmAerowayLinestring.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmAerowayPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmAerowayPoint.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmHighwayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmHighwayLinestring.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmRailwayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmRailwayLinestring.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmAerialwayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmAerialwayLinestring.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmShipwayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmShipwayLinestring.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmHighwayPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmHighwayPolygon.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmBuildingPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmBuildingPolygon.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmMarinePoint.Handler typedHandler) {
        result.computeIfAbsent(OsmMarinePoint.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmContinentPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmContinentPoint.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmCountryPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmCountryPoint.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmIslandPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmIslandPolygon.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmIslandPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmIslandPoint.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmStatePoint.Handler typedHandler) {
        result.computeIfAbsent(OsmStatePoint.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmCityPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmCityPoint.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmHousenumberPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmHousenumberPoint.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmPoiPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmPoiPoint.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmPoiPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmPoiPolygon.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
      if (handler instanceof OsmAerodromeLabelPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmAerodromeLabelPoint.class, cls -> new HashSet<>()).add(typedHandler.getClass());
      }
    }
    return result;
  }

  public static Map<Class<? extends Row>, List<RowHandler<? extends Row>>> generateDispatchMap(List<?> handlers) {
    Map<Class<? extends Row>, List<RowHandler<? extends Row>>> result = new HashMap<>();
    for (var handler : handlers) {
      if (handler instanceof OsmWaterPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmWaterPolygon.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmWaterPolygon>) typedHandler::process);
      }
      if (handler instanceof OsmWaterwayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmWaterwayLinestring.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmWaterwayLinestring>) typedHandler::process);
      }
      if (handler instanceof OsmLandcoverPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmLandcoverPolygon.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmLandcoverPolygon>) typedHandler::process);
      }
      if (handler instanceof OsmLandusePolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmLandusePolygon.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmLandusePolygon>) typedHandler::process);
      }
      if (handler instanceof OsmPeakPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmPeakPoint.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmPeakPoint>) typedHandler::process);
      }
      if (handler instanceof OsmParkPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmParkPolygon.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmParkPolygon>) typedHandler::process);
      }
      if (handler instanceof OsmAerowayPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmAerowayPolygon.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmAerowayPolygon>) typedHandler::process);
      }
      if (handler instanceof OsmAerowayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmAerowayLinestring.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmAerowayLinestring>) typedHandler::process);
      }
      if (handler instanceof OsmAerowayPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmAerowayPoint.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmAerowayPoint>) typedHandler::process);
      }
      if (handler instanceof OsmHighwayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmHighwayLinestring.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmHighwayLinestring>) typedHandler::process);
      }
      if (handler instanceof OsmRailwayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmRailwayLinestring.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmRailwayLinestring>) typedHandler::process);
      }
      if (handler instanceof OsmAerialwayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmAerialwayLinestring.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmAerialwayLinestring>) typedHandler::process);
      }
      if (handler instanceof OsmShipwayLinestring.Handler typedHandler) {
        result.computeIfAbsent(OsmShipwayLinestring.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmShipwayLinestring>) typedHandler::process);
      }
      if (handler instanceof OsmHighwayPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmHighwayPolygon.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmHighwayPolygon>) typedHandler::process);
      }
      if (handler instanceof OsmBuildingPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmBuildingPolygon.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmBuildingPolygon>) typedHandler::process);
      }
      if (handler instanceof OsmMarinePoint.Handler typedHandler) {
        result.computeIfAbsent(OsmMarinePoint.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmMarinePoint>) typedHandler::process);
      }
      if (handler instanceof OsmContinentPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmContinentPoint.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmContinentPoint>) typedHandler::process);
      }
      if (handler instanceof OsmCountryPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmCountryPoint.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmCountryPoint>) typedHandler::process);
      }
      if (handler instanceof OsmIslandPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmIslandPolygon.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmIslandPolygon>) typedHandler::process);
      }
      if (handler instanceof OsmIslandPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmIslandPoint.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmIslandPoint>) typedHandler::process);
      }
      if (handler instanceof OsmStatePoint.Handler typedHandler) {
        result.computeIfAbsent(OsmStatePoint.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmStatePoint>) typedHandler::process);
      }
      if (handler instanceof OsmCityPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmCityPoint.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmCityPoint>) typedHandler::process);
      }
      if (handler instanceof OsmHousenumberPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmHousenumberPoint.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmHousenumberPoint>) typedHandler::process);
      }
      if (handler instanceof OsmPoiPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmPoiPoint.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmPoiPoint>) typedHandler::process);
      }
      if (handler instanceof OsmPoiPolygon.Handler typedHandler) {
        result.computeIfAbsent(OsmPoiPolygon.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmPoiPolygon>) typedHandler::process);
      }
      if (handler instanceof OsmAerodromeLabelPoint.Handler typedHandler) {
        result.computeIfAbsent(OsmAerodromeLabelPoint.class, cls -> new ArrayList<>())
          .add((RowHandler<OsmAerodromeLabelPoint>) typedHandler::process);
      }
    }
    return result;
  }
}
